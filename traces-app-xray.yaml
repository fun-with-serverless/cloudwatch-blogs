AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Parameters:
  ErrorRate:
    Type: Number
    Default: 0.3
    Description: Probability of generating a DynamoDB error (0-1)

Globals:
  Function:
    Runtime: nodejs22.x
    Timeout: 30
    MemorySize: 128

Resources:
  DataTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub ${AWS::StackName}-data
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST

  ProcessingQueue:
    Type: AWS::SQS::Queue

  ServiceAFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      Environment:
        Variables:
          TABLE_NAME: !Ref DataTable
          QUEUE_URL: !Ref ProcessingQueue
          ERROR_RATE: !Ref ErrorRate
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref DataTable
        - SQSSendMessagePolicy:
            QueueName: !GetAtt ProcessingQueue.QueueName
      Events:
        ApiEvent:
          Type: Api
          Properties:
            Path: /process
            Method: post
      InlineCode: |
        const { DynamoDBClient, PutItemCommand } = require('@aws-sdk/client-dynamodb');
        const { SQSClient, SendMessageCommand } = require('@aws-sdk/client-sqs');
        const { marshall } = require('@aws-sdk/util-dynamodb');

        const dynamodb = new DynamoDBClient();
        const sqs = new SQSClient();

        exports.handler = async (event) => {
            try {
                const body = JSON.parse(event.body);
                const { userId, data } = body;
                
                if (!userId) {
                    return {
                        statusCode: 400,
                        body: JSON.stringify({ error: 'userId is required' })
                    };
                }

                const timestamp = new Date().toISOString();
                const item = {
                    userId,
                    timestamp,
                    data,
                    requestContext: event.requestContext
                };

                const shouldError = Math.random() < parseFloat(process.env.ERROR_RATE);
                const putCommand = new PutItemCommand({
                    TableName: process.env.TABLE_NAME,
                    Item: shouldError ? 
                        marshall({
                            timestamp,
                            data
                        }) :
                        marshall(item)
                });

                await dynamodb.send(putCommand);

                const sqsCommand = new SendMessageCommand({
                    QueueUrl: process.env.QUEUE_URL,
                    MessageBody: JSON.stringify(item)
                });
                await sqs.send(sqsCommand);

                return {
                    statusCode: 200,
                    body: JSON.stringify({
                        message: 'Data processed successfully',
                        timestamp
                    })
                };
            } catch (error) {
                console.error('Error:', error);
                return {
                    statusCode: 500,
                    body: JSON.stringify({
                        error: error.message
                    })
                };
            }
        };

  ServiceBFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt ProcessingQueue.Arn
            BatchSize: 1
      InlineCode: |
        exports.handler = async (event) => {
            for (const record of event.Records) {
                try {
                    const message = JSON.parse(record.body);
                    console.log('Processing message:', message);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    console.log('Message processed successfully:', message);
                } catch (error) {
                    console.error('Error processing message:', error);
                    throw error;
                }
            }
        };

  TestFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      Environment:
        Variables:
          API_ENDPOINT: !Sub https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod
      Policies:
        - Statement:
            - Effect: Allow
              Action:
                - execute-api:Invoke
              Resource: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ServerlessRestApi}/*/*/*
      InlineCode: |
        const makeRequest = async () => {
            const testUser = {
                userId: `test-user-${Date.now()}`,
                data: {
                    timestamp: new Date().toISOString(),
                    message: 'Test request'
                }
            };

            const response = await fetch(`${process.env.API_ENDPOINT}/process`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(testUser)
            });

            const data = await response.json();
            return {
                statusCode: response.status,
                data
            };
        };

        exports.handler = async (event) => {
            const results = [];
            for (let i = 0; i < 50; i++) {
                try {
                    const result = await makeRequest();
                    results.push(result);
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.error(`Request ${i + 1} failed:`, error);
                    results.push({ 
                        error: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
            }

            return {
                statusCode: 200,
                body: {
                    message: 'Test completed',
                    results
                }
            };
        };

Outputs:
  ApiEndpoint:
    Description: API Gateway endpoint URL
    Value: !Sub https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod
  TestFunction:
    Description: Test Function Name
    Value: !Ref TestFunction